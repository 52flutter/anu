{"./":{"url":"./","title":"介绍","keywords":"","body":"anu npm install anujs anu, 读作［安努］，原意为苏美尔的主神。 众所周知，React 一直存在体积过大的诟病，集成了许多在线上环境不需要功能, 因此我在熟读其源码的基础上，去芜存精，重新实现了 React 所有公开接口，体积只有其五分之一，从而解决它在移动端上加载过慢的问题。由于没有使用高级 API，因此只需在 webpack ,uglify 上修改配置，便能运用于 IE8 上，从而解决 PC 端同学使用 React 的问题。 与其他迷你react的比较 相对于preact， 它的通用性更好， preact是通过preact-compat实现对React的API的兼容，里面用于了Object.definePropety，这会造成两个问题。 一是无法运用于IE8中，二，用于Object.defineProperty,其性能立即从70帧掉到30帧。 相对于react-lite, anujs的事件系统更具扩展性。官方的react-dom，近2万行，有一半花在事件系统上，对mouseenter/mouseleave/focus/blur/change等不可冒泡的事件进行模拟冒泡，react-lite简单几行是实现不了那个效果的。 anujs是作者是精通DOM操作，也费了好大劲才实现的。 －－－－－－－－－－ 特点： 支持React的无狀态组件，纯组件，高阶组件，受控组件与非受控组件， 命名空间就是React，此外还暴露了另一个别名ReactDOM在window上 体积足够少，min为60k, gz后为16中，2000多行代码（相对于react+react-dom是3MB与3万行代码) 性能稳定在60帧，使用的是基于列队的异步机制 生命周期函数的参数与官方保持一致 直接与react-redux, react-router-dom, react-router-redux混用 支持后端渲染 支持官方的chrome DevTools 详细用法与示例见 wiki class A extends React.PureComponent { constructor(props) { super(props) this.state = { aaa: { a: 7 } } } click() { this.setState(function(state){ state.aaa.a = 8 }) } render() { return {this.state.aaa.a} } } window.onload = function () { ReactDOM.render(, document.getElementById('example')) } 这个怎么点击也不会变 与Redux使用的例子 var addTodoActions = function (text) { return { type: 'add_todo', text: text }; } var todoReducer = function (state, action) { if (typeof state === 'undefined') { return []; } switch (action.type) { case 'add_todo': return state.slice(0).concat({ text: action.text, completed: false }); break; default: return state; } }; var store = Redux.createStore(todoReducer); class App extends React.Component { constructor(props){ super(props) this.state = { items: store.getState() } this.onChange = this.onChange.bind(this) this.handleKeyUp = this.handleKeyUp.bind(this) this.handleAdd = this.handleAdd.bind(this) } componentDidMount(){ var unsubscribe = store.subscribe(this.onChange); } onChange(){ this.setState({ items: store.getState() }); } handleKeyUp(e){ if(e.which === 13){ this.handleAdd() } } handleAdd(){ var input = this.refs.todo var value = input.value.trim(); if(value) store.dispatch(addTodoActions(value)); input.value = ''; } render(){ return ( 点击添加 {this.state.items.map(function(item){ return {item.text}; })} ); } }; ReactDOM.render( , document.getElementById('example') ); 测试 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 14:33:26 "},"install.html":{"url":"install.html","title":"安装","keywords":"","body":"安装 npm i anujs 如何在已经使用了React的项目中使用，修改webpack.config.js resolve: { alias: { 'react': 'anujs', 'react-dom': 'anujs', 'react-tap-event-plugin': 'anujs/lib/injectTapEventPlugin' 　//如果你用到了onTouchTap事件 } } Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"warn.html":{"url":"warn.html","title":"注意事项","keywords":"","body":"注意点 它没有实现如下方法： replaceState isMounted setProps replaceProps 这些方法在所有迷你库都没有实现，官网上也不再出现，逐渐变边缘化与可能被废弃，不建议使用 https://facebook.github.io/react/docs/react-component.html 低版本浏览器可能需要以下 语言补丁, 详见IE栏目的处理 Array.isArray Object.assign JSON.stringify console-polyfill Object.keys Object.is Array.prototype.forEach Function.prototype.bind 或者直接使用polyfill.js https://github.com/RubyLouvre/anu/blob/master/lib/polyfill.js 并且还需要修复Array.prototype.splice的BUG Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 14:05:00 "},"version.html":{"url":"version.html","title":"版本变更","keywords":"","body":"1.1.1 简化createClass 1.1.0 disabled的元素不能触发点击事件 修正mouseenter/mouseleave在IE6－8中的BUG，涉及到relatedTarget的正确获取与LCA处理 简化alignVnode的逻辑，减少插入列队的生成 重构setStateImpl, _component更名为__component, _currentElement更名为__current react/lib中添加一些简用的外围模块，如ReactComponentWithPureRenderMixin，shallowCompare，sliceChildren 1.0.8 event.originalEvent更名为 event.nativeEvent 修正polyfill中forEach的BUG 移除scheduler模块 移除instanceMap模块 修正typeNumber在iE6－8下的BUG eventSystem.addGlobalEventListener更名为eventSystem.addGlobalEvent 规避insertBfore在IE8下第二参数不能为 undefined的问题 修正ref延迟执行的BUG，组件所在的vnode如果有ref属性，那么它应该放到此组件的pendingRefs数组中，而不是放在父组件的pendingRefs数组 此外__pendingRefs数组里的元素由对象改成函数 确保组件在componentDidMount钩子执行setState后，所有回调应延迟到componentDidUpdate外执行 确保mountComponent中实例应该尽快保存到vnode中 修正updateElement方法中只执行一次dangerouslySetInnerHTML的BUG 处理mouseenter/mouseleave的兼容问题 处理focus/blur的兼容问题 1.0.7 处理用户在render方法 return this.props.children 的情况，需要将数组转换为单个虚拟DOM 处理两个组件虚拟DOM都没有实例化的情况 只回收文本节点 支持mouseenter/mouseleave及重构事件系统 1.0.6 重新支持chrome DevTools 添加对Immutable.js的支持 修复用户在componentWillUpdate/shouldComponentUpdate/componentDidUpdate钩子中执行setState引发死循环的BUG 1.0.5 优化scheduler机制 实现对createFactory的支持 优化dispose模块 使用typeNumber代替typeof关键字，减少打包后的体积 1.0.4 修正 unable to preventdefault inside passive event listener due to target 的错误处理， 这是chrome51+, 为了提高性能，默认对touchmove/mousemove/mousewheel事件禁用preventDefault方法引发的问题 销毁元素节点，彻底清除_component与__events引用 取消refs.xxx = null 操作，确保组件销毁后可能还进行动画，这时会有DOM操作不会报错 对props.children进行增强，支持更多合法的类型 实现对createClass的支持 实现对mixin的支持 1.0.3 实现unstable_renderSubtreeIntoContainer, findDOMNode, isValidElement方法 实现对Children的完整支持 (only, count, forEach,map, toArray) 实现focus, blur, wheel的兼容处理， 修正更新组件时，没有添加defaultProps的BUG 修正diffProps一些错别字 实现事件对象pagex,pageY,which,currentTarget的兼容 修正用户在componentWillMount时调用 setState引发的BUG cloneElement应该能处理数组并取出其第一个元素进制复制 取消事务机制，改成调度任务 1.0.2 兼容IE，实现对应的polyfill文件 实现对IE6－8的change, input, submit事件 添加对select.value的处理 1.0.1 支持cloneElement 1.0.0 发布anu Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 14:07:03 "},"jsx.html":{"url":"jsx.html","title":"JSX","keywords":"","body":"JSX React的核心机制之一就是可以在内存中创建虚拟DOM。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。 为了方便使用虚拟DOM，React发明了JSX， 可以简单地理解它是一种在JS中编写与XML类似的语言。通过JSX来声明组件的属性，类型与结果，并且通过｀{}`插值，套嵌JS逻辑与子级的JSX。 要JSX语法，你必须要引入babel的JSX解析器，把JSX转化成JS语法，这个工作会由babel自动完成。同时引入babel后，你就可以使用新的es6语法，babel会帮你把es6语法转化成es5语法，兼容更多的浏览器。 大家可以在这里下载最新版babel http://www.bootcdn.cn/babel-core/ JSX的特点： 类XML语法容易接受，结构清晰 增强JS语义 抽象程度高，屏蔽DOM操作，跨平台 代码模块化 我们从最简单的一个官网例子helloworld开始： Hello React! ReactDOM.render( Hello, world!, document.getElementById('example') ); script标签里面的内容实际会被编译成 ReactDOM.render( React.createElement('h1',null, 'Hello, world!'), document.getElementById('example') ); 又如 var root =( First Text Content Second Text Content ); 会被编译成 var root = React.createElement('ul', { className: 'my-list' }, React.createElement('li', null, 'First Text Content'), React.createElement('li', null, 'Second Text Content') ); JSX语法介绍 ｀{}`插值是让JSX区别普通HTML的一个重要特性，只有三个地方可以使用它。可以放属性名的地方，属性等于号之后的位置及innerHTML之间。 1.可以放属性名的地方, 这里只能使用JSXSpreadAttribute(延伸属性)， 换言之，括号内必须带三个点号 var props = {}; props.foo = x; props.bar = y; var component = ; 2.属性等于号之后的位置, JSX的属性值必须用引号括起来，当你将引号改成花括号，它里面就可以使用JSX变量了。相当于其他框架的绑定属性或指令。需要说明一下，HTML的固有属性必须使用JS形式，保持驼峰风格，如class要用className代替，for要用htmlFor代替，tabindex要用tabIndex代替，colspan要用colSpan代替。 花括号里面可以使用三元表达式 var person = ; 会编译成 var person = React.createElement( Person, {name: window.isLoggedIn ? window.name : ''} ); 3.innerHTML xxx{111}yyy 这个会编译成, 相邻的字任串或数字会合并成一个字符串，布尔，null, undefined会被忽略掉。 React.createElement('div',null,\"xxx111yyy\") 在innerHTML里面，我们可以使用数组或数组的map方法生成一个新数组的方法，为当前父元素添加一堆子元素。 var ul = ( { this.todoList.todos.map(function (todo) { return ( {todo.text} ); }) } ); JSX中绑定事件 JSX让事件直接绑定在元素上。 Submit 和原生HTML定义事件的唯一区别就是JSX采用驼峰写法来描述事件名称，大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。 React并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的Listener，然后通过事件的target找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React模拟事件系统。尽管整个事件系统由React管理，但是其API和使用方法与原生事件一致。 JSX中使用样式 在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，`属性值不能是字符串而必须为对象｀。 Hello World. 或者 var style = { color: '#ff0000', fontSize: '14px' }; var node = HelloWorld.; 要明确记住,{}里面是JS代码,这里传进去的是标准的JS对象。在JSX中可以使用所有的的样式，基本上属性名的转换规范就是将其写成驼峰写法，例如“background-color”变为“backgroundColor”, “font-size”变为“fontSize”，这和标准的JavaScript操作DOM样式的API是一致的。 HTML转义 在组件内部添加html代码,并将html代码渲染到页面上。React默认会进行HTML的转义，避免XSS攻击， 如果要不转义，可以使用dangerouslySetInnerHTML属性。dangerouslySetInnerHTML要求对应一个对象，里面有一个叫__html的字符串。React故意搞得这么难写，目的让大家少点用它。 var content='content'; React.render( , document.body ); 注意：JSX里面br，input, hr等标签必须自闭合，如必须写成 并且使用了dangerouslySetInnerHTML，就不能在元素内部添加子元素，像下面的写法是错的 12 属性的定义 JSX是严格区分固有属性与自定义属性， 固有属性是指元素原形链上就已存在的属性，比如id, title, className, htmlFor, style，colSpan。这些属性是严格区分大小写。并且对属性值也有要求。 固有属性根据其值的类型，可以分为布尔属性与字符串属性。布尔属性一般出现在表单元素与A，script等标签上，如disabled, readOnly, selected, checked等等。布尔属性时，大家在使用时，值必须是布尔 //anu内部的所有布尔属性 autofocus,autoplay,async,allowTransparency,checked,controls,declare,disabled,defer,defaultChecked,defaultSelected,isMap,loop,multiple,noHref,noResize,noShade,open,readOnly,selected 字符串属性也比较常见： value,id,title,alt,htmlFor,longDesc,className 还有一些不规则的属性(不需要刻意记，只要记住上面两种就是) accessKey,bgColor,cellPadding,cellSpacing,codeBase,codeType,colSpan,dateTime,defaultValue,contentEditable,frameBorder,maxLength,marginWidth,marginHeight,rowSpan,tabIndex,useMap,vSpace,valueType,vAlign 而自定义属性，则是用户随便设置的。 自定义组件 组件定义之后，可以利用XML语法去声明，而能够使用的XML Tag就是在当前JavaScript上下文的变量名,该变量名就是组件名称。 一般来说，我们可以通过标签名的第一个字母是大写还是小写来识别组件与普通标签。 class HelloWorld extends React.Component{ render() { return ( Hello, ! It is {this.props.date.toTimeString()} ); } }; setInterval(function() { ReactDOM.render( , document.getElementById('example') ); }, 500); Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"component.html":{"url":"component.html","title":"组件","keywords":"","body":"组件 自从chrome推出web component后，将组件实现标签化的思潮又一次回到我们眼前。上一次是JSP时代。 React/anu中使用组件非常简单，就是将标签名改成类名就行了。 React也经过几次迭代，定义组件的方式改成es6的class来定义组件，只要求它继续React.Component类及添加一个render方法就行了。但这个也不是必须的，因为后来出现了无状态组件。让我们梳理一下React定义组件的三种方式吧，分别有 有状态组件，纯组件，无状态组件。 1.有状态组件 class Input extends React.Component{ constructor(props){ super(props) this.state = { value: 'xxx' } this.onChange = this.onChange.bind(this) } onChange(e){ this.setState( value: e.target.value ) } render(){ return } } ReactDOM.render(, rootElement) 2.纯组件 纯数组与有状态组件唯一不同就是其父类。父类为它指定了特殊的shouldComponentUpdate。当用户调用了setState，或父组件发生render操作时，子组件也会发生render操作，这时我们可以指定shouldComponentUpdate方法，通过返回false阻止此组件进行更新。 为了减少无效的更新操作，shouldComponentUpdate的实现是非常关键的，因此在早期React版本中有一个叫PureRenderMixin插件非常受欢迎。返回此组件就整合到React中，诞生了现在的纯组件。 class Input extends React.PureComponent{ constructor(props){ super(props) this.state = { value: 'xxx' } this.onChange = this.onChange.bind(this) } onChange(e){ this.setState( value: e.target.value ) } render(){ return } } ReactDOM.render(, rootElement) 3.无状态组件 一个数组是总继承什么父类，必须消耗许多性能，并且在组件挂载到DOM树或更新过程中，会触发一系列生命周期钩子，这也会消耗性能。为了避开所有这一切的性能损失，于是React推出了无状态组件。无状态组就是一个普通的函数，特殊之处是函数的第一个字母大写，接受两个参数(props与context)，返回JSX。 function Input (props, context){ return } ReactDOM.render(, rootElement) 组件的属性与方法 当我们继承React.Component或React.PureComponent时，会获得一些对象与方法。首先是4个对象，props, state, context, refs与一些改变组件状态的方法，setState, forceUpdate及生命周期钩子。 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"props.html":{"url":"props.html","title":"Props","keywords":"","body":"props props是用来描述组件的外部状态，并且能往下传递的，通常来说，props里面还存在一个children数组，如果不存在子组件，也可以不用写。为了性能起见，props变设计成不可改变，只能在JSX 里使用attributes形式进行定义。 class HelloMessage extends React.Component{ render: function() { //这里的props就等于rubylouvre return Hello {this.props.name}; } } ReactDOM.render( , document.getElementById('example') 默认属性 为了减少最终使用组件的用户的工作量，我们可以在类名里添加一个对象，来集中定义默认属性。 class Parent extends React.Component { render() { return () } } Parent.defaultProps = { name: '我在这里' } function HelloComponent(props, context) { return (Hello {props.name}) } window.onload = function() { ReactDOM.render(, document.getElementById('example')); } 这个默认会被清掉 你也可以使用静态的访问器属性 class Parent extends React.Component { static defaultProps = { name: \"静态\" } render() { return () } } function HelloComponent(props, context) { return (Hello {props.name}) } window.onload = function() { ReactDOM.render(, document.getElementById('example')); } 这个默认会被清掉 如果你安装了bable这个babel-plugin-transform-class-properties插件，还可以这样写 https://www.npmjs.com/package/babel-plugin-transform-class-properties class Parent extends React.Component { static get defaultProps() { return { name: \"静态\" } } render() { return () } } function HelloComponent(props, context) { return (Hello {props.name}) } window.onload = function() { ReactDOM.render(, document.getElementById('example')); } 这个默认会被清掉 属性验证 在开发环境中，我们可以PropTypes 提供的许多验证器 (validator) 来检查传入数据的有效性。当向 props 传入无效数据时，JavaScript 控制台会抛出警告。下面用例子来说明不同验证器的区别： class Hello extends Component { render(){ return ( hello { this.props.name } ); } } Hello.propTypes ＝ { // 可以声明 prop 为指定的 JS 基本类型。默认 // 情况下，这些 prop 都是可传可不传的。 optionalArray: React.PropTypes.array, optionalBool: React.PropTypes.bool, optionalFunc: React.PropTypes.func, optionalNumber: React.PropTypes.number, optionalObject: React.PropTypes.object, optionalString: React.PropTypes.string, // 所有可以被渲染的对象：数字， // 字符串，DOM 元素或包含这些类型的数组。 optionalNode: React.PropTypes.node, // React 元素 optionalElement: React.PropTypes.element, // 用 JS 的 instanceof 操作符声明 prop 为类的实例。 optionalMessage: React.PropTypes.instanceOf(Message), // 用 enum 来限制 prop 只接受指定的值。 optionalEnum: React.PropTypes.oneOf(['News', 'Photos']), // 指定的多个对象类型中的一个 optionalUnion: React.PropTypes.oneOfType([ React.PropTypes.string, React.PropTypes.number, React.PropTypes.instanceOf(Message) ]), // 指定类型组成的数组 optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number), // 指定类型的属性构成的对象 optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number), // 特定形状参数的对象 optionalObjectWithShape: React.PropTypes.shape({ color: React.PropTypes.string, fontSize: React.PropTypes.number }), // 以后任意类型加上 `isRequired` 来使 prop 不可空。 requiredFunc: React.PropTypes.func.isRequired, // 不可空的任意类型 requiredAny: React.PropTypes.any.isRequired, // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接 // 使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。 customProp: function(props, propName, componentName) { if (!/matchme/.test(props[propName])) { return new Error('Validation failed!'); } } } 在React 15.5中，主 React.PropTypes已经被剥离到独立的仓库中。 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"state.html":{"url":"state.html","title":"State","keywords":"","body":"State state的作用 state是React中组件的一个对象。React把用户界面当做是状态机，想象它有不同的状态然后渲染这些状态,可以轻松让用户界面与数据保持一致。 React中，更新组件的state，会导致重新渲染用户界面(不要操作DOM)。简单来说，就是用户界面会随着state变化而变化。 state工作原理 常用的通知React数据变化的方法是调用setState(data,callback)。这个方法会合并data到this.state，并重新渲染组件。渲染完成后，调用可选的callback回调.大部分情况不需要提供callback,因为React会负责吧界面更新到最新状态. 那些组件应该有state? 大部分组件的工作应该是从props里取数据并渲染出来。但是，有时需要对用户输入，服务器请求或者时间变化等作出响应，这时才需要state。 组件应该尽可能的无状态化，这样能隔离state，把它放到最合理的地方(Redux做的就是这个事情?)，也能减少冗余并易于解释程序运作过程。 常用的模式就是创建多个只负责渲染数据的无状态(stateless)组件，在他们的上层创建一个有状态(stateful)组件并把它的状态通过props 传给子级。有状态的组件封装了所有的用户交互逻辑，而这些无状态组件只负责声明式地渲染数据. 哪些应该作为state? state应该包括那些可能被组件的事件处理器改变并触发用户界面更新的数据。这中数据一般很小且能被JSON序列化。当创建一个状态化的组件的时候， 应该保持数据的精简，然后存入this.state。在render()中在根据state来计算需要的其他数据。因为如果在state里添加冗余数据或计算 所得数据，经常需要手动保持数据同步。 那些不应该作为state? this.state应该仅包括能表示用户界面状态所需要的最少数据。因此，不应该包括： 计算所得数据 React组件, 在render()里使用props和state来创建它。 基于props的重复数据。 尽可能保持用props来做作为唯一的数据来源.把props保存到state中的有效的场景是需要知道它以前的值得时候,因为未来的props可能会变化. setState的操作时机 componentDidMount钩子 componentWillReceiveProps钩子 事件回调 setTimeout回调 在组件的其他生命周期钩子里操作setState可能引起不断更新组件自身，导致页面僵死！ Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"context.html":{"url":"context.html","title":"Context","keywords":"","body":"context 在React中，数据总是自上而下的传递，每当你使用一个组件的时候，你可以看到组件的props属性会自上而下的传递。 但是如果一个页面结构非常复杂，你在在某一种子组件获得其祖先组件的某个属性来干某事时，就非常麻烦了。虽然在React内部存在一个叫 _hostParent的属性，类似于DOM的parentNode来让你回溯其祖先，但毕竟是没有记录在文档上的内部属性，不适宜使用它。 于是到context出场了。 在官方React中，context一般与getChildContext,childContextTypes一起使用。在anu中，所有数据验证的东西已经干掉， 因此只要用context、getChildContext就行了。 class Parent extends React.Component{ render() { return () } } class Son extends React.Component{ render() { return ( {this.context.value} ) } } class App extends React.Component{ getChildContext() { return { value: 666 }; } render() { return () } }; window.onload = function() { ReactDOM.render(, document.getElementById('example')); } 这个默认会被清掉 React的context和全局变量相似，应避免使用，场景包括：传递登录信息、当前语音以及主题信息； 如果只传递一些功能模块数据，则尽量不要使用context，使用props传递数据会更加清晰； 使用context会使组件的复用性降低，因为这些组件依赖'上下文'，当你在别的地方渲染的时候，可能会出现差异； Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"refs.html":{"url":"refs.html","title":"Refs","keywords":"","body":"refs 在组件实例中，存在一个叫refs的对象，在组件render时，框架会将JSX中定义了ref属性的标签对应的DOM节点或实例收集到这个对象。 当ref为一个字符串时，其所在标签的tagName是小写，那么它就会收集其DOM节点，如果标签名是大写开头，那么就会收集其组件实例。 class Com extend React.Component{ render(){ return } } var s = ReactDOM.render(, document.body) console.log(s.refs.input) //返回input这个真实DOM 此外，ref也可以是一个函数，这时它的传参就是DOM节点或组件实例，它会在组件挂载或卸载时各执行一次，然后在ref对应的函数发生变化时也会执行一次。 在卸载时，传参总是为null function TestComp(props){ let refDom; return ( refDom = node}> ... ) } 值得注意的是，无状态组件由于没有实例，因此不会对 ref进行任何处理。 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"lifecycle.html":{"url":"lifecycle.html","title":"生命周期","keywords":"","body":"组件的生命周期钩子 React的组件机制非常出色，不仅在于其标签化的设计，还在于它的生命周期非常完整，在每个阶段都有不同的钩子供你调用。 早期一共有10个钩子，在es6类流行后，精简为8个，getDefaultProps 与 getInitialState被废弃了。 我们可以把组件生命周期大致分为三个阶段： 第一阶段：是组件挂载阶段 getDefaultProps 或es6 Class.defaultProps getInitialState 或es6 this.state componentWillMount render componentDidMount 第二阶段：是组件在运行和交互阶段 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 第三阶段：是组件卸载阶段 componentWillUnmount 说明 componentWillMount() 在完成首次渲染之前调用，此时仍可以修改组件的state。 render() 必选的方法，创建虚拟DOM，该方法具有特殊的规则： 只能通过this.props和this.state访问数据 可以返回null、false或任何React组件 只能出现一个顶级组件（不能返回数组） 不能改变组件的状态 不能修改DOM的输出 componentDidMount() 真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。 在服务端中，该方法不会被调用。 componentWillReceiveProps(nextProps, parentContext) 组件接收到上面传下来的props, context做参数，大家可以在这里进行setState操作 componentWillReceiveProps: function(nextProps) { if (nextProps.bool) { this.setState({ bool: true }); } } shouldComponentUpdate(nextProps, nextState, parentContext) 组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。 在出现应用的瓶颈时，可通过该方法进行适当的优化。 在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用 componentWillUpdate(nextProps, nextState, parentContext) 接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。 componentDidUpdate(prevProps, prevState, prevContext) 完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。注意这里的参数，props, state, context都是没有更新前的，可以给你一个回滚的机会 componentWillUnmount 组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销， 比如创建的定时器或添加的事件监听器。 生命周期 调用次数 能否使用 setSate() componentWillMount 1 是 render >=1 否 componentDidMount 1 是 componentWillReceiveProps >=0 是 shouldComponentUpdate >=0 否 componentWillUpdate >=0 否 componentDidUpdate >=0 否 componentWillUnmount 1 否 class LifeCycle extends React.Component { constructor(props) { super(props); alert(\"Initial render\"); alert(\"constructor\"); this.state = {str: \"hello\"}; } componentWillMount() { alert(\"componentWillMount\"); } componentDidMount() { alert(\"componentDidMount\"); } componentWillReceiveProps(nextProps) { alert(\"componentWillReceiveProps\"); } shouldComponentUpdate() { alert(\"shouldComponentUpdate\"); return true; // 记得要返回true } componentWillUpdate() { alert(\"componentWillUpdate\"); } componentDidUpdate() { alert(\"componentDidUpdate\"); } componentWillUnmount() { alert(\"componentWillUnmount\"); } setTheState() { let s = \"hello\"; if (this.state.str === s) { s = \"HELLO\"; } this.setState({ str: s }); } forceItUpdate() { this.forceUpdate(); } render() { alert(\"render\"); return( {\"Props:\"}{parseInt(this.props.num)} {\"State:\"}{this.state.str} ); } } class Container extends React.Component { constructor(props) { super(props); this.state = { num: Math.random() * 100 }; } propsChange() { this.setState({ num: Math.random() * 100 }); } setLifeCycleState() { this.refs.rLifeCycle.setTheState(); } forceLifeCycleUpdate() { this.refs.rLifeCycle.forceItUpdate(); } unmountLifeCycle() { // 这里卸载父组件也会导致卸载子组件 React.unmountComponentAtNode(document.getElementById(\"container\")); } parentForceUpdate() { this.forceUpdate(); } render() { return ( propsChange setState forceUpdate unmount parentForceUpdateWithoutChange ); } } ReactDom.render( , document.getElementById('container') ); Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"event.html":{"url":"event.html","title":"事件","keywords":"","body":"事件系统 早期的DOM 0事件系统，是在标签内直接添加 onxxx=\"fn\"属性，这有巨大的缺点： 一是只能应用于冒泡阶段 二是fn为全局函数 三是this与事件对象存在兼容性问题 但onxxx方法非常明了，因此React对它做了一些改进， onClick属性可以在后面添加Capture字样，让它在捕获阶段执行，即onClick对应着onClickCapture， onChange对应着onChangeCapture 回调函数通过编译手段，将它改成局部 回调的this指向组件实例，事件对象框架做了标准化处理，并且通过回收机制，不断重复使用此方法。 点我 在React.createClass时代，组件的回调函数都是自动bind this，保持它们总是指向实例本身。但是在es6时，则没有这个免费服务了。 你可以通过babel-plugin-transform-class-properties这插件， 实现在class块中直接使用箭头函数。众所周知， 箭头函数是autobind this的 let {Component, PropTypes} = React; export default class MyComponent extends Component { // lifecycle methods and statics static propTypes = { foo: PropTypes.bool.isRequired } handler = (e) => { ... } // render actual DOM output render() { return ; } } 此外你也可以使用autobind-decorator这个模块，直接用es7的注解 搞定这个问题 anujs在0.0.3版，可以通过React.eventSystem来访问各种事件API https://github.com/andreypopp/autobind-decorator import autobind from 'autobind-decorator' class Component { constructor(value) { this.value = value } @autobind method() { return this.value } } let component = new Component(42) let method = component.method // .bind(component) isn't needed! method() // returns 42 // Also usable on the class to bind all methods @autobind class Component { } 如果大家想在移动端使用触屏事件，可以尝试使用 lib/injectTapEventPlugin.js injectTapEventPlugin() //必须执行这个 window.onload = function(){ class App extends React.Component { constructor(props) { super(props); this.state = { aaa: 1111 }; } componentWillMount() { this.state = { aaa: 333 } this.forceUpdate(); } render() { return { console.log('用户触发',e.type)}}>{this.state.aaa}; } } var s = ReactDOM.render(, document.getElementById('example')); } 开发者工具 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"uncontrolledComponent.html":{"url":"uncontrolledComponent.html","title":"受控组件与非受控组件","keywords":"","body":"受控组件与非受控组件 一些表单元素，如select, textarea, input存在受控与非受控之分。受控就是用户可以通过点击，输入，选择等行为来控制其value/checked的改变，非受控则反之。 value, checked是表单元素两个很特殊的属性，决定着元素的外观。 当用户为表单元素指定了value, checked属性，那么框架就会进一步判定用户有没有定义其他用于控制它改变的属性与事件，比如说disabled, readOnly, onChange, onClick, onInput。如果有，它就是受控组件，没有就是非受控组件。 非受控组件的情况下，框架会在内部添加一些事件，阻止用户手动改变value/checked，这时用户只能通过setState来改变。 强烈建议，表单元素一定要弄成受控组件。 否则你不要使用value/checked，而是改用defaultValue/defaultChecked。 var textarea, radio, text, select, checkbox window.onload = function(){ class Text extends React.Component{ constructor(props) { super(props); this.state={value:'Hello'}; this.handleChange=this.handleChange.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } render() { var value = this.state.value; return ; } } class Checkbox extends React.Component{ constructor(props) { super(props); this.state={checked: false}; this.handleChange=this.handleChange.bind(this); } handleChange(event) { this.setState({checked: event.target.checked}); } render() { var value = this.state.value; return ; } } class Radio extends React.Component{ constructor(props) { super(props); this.state={checked: false}; this.handleChange=this.handleChange.bind(this); } handleChange(event) { this.setState({checked: event.target.checked}); } render() { var value = this.state.value; return } } class TextArea extends React.Component{ constructor(props) { super(props); this.state={value: 'dddd'}; this.handleChange=this.handleChange.bind(this); } handleChange(event) { this.setState({value: event.target.checked}); } render() { return } } class Select extends React.Component { constructor() { super() this.state = { value: 'bbb' } } render() { return aaa bbb ccc } } text = ReactDOM.render( , document.getElementById('text') ) checkbox = ReactDOM.render( , document.getElementById('checkbox') ) radio = ReactDOM.render( , document.getElementById('radio') ) textarea = ReactDOM.render( , document.getElementById('textarea') ) select = ReactDOM.render( , document.getElementById('select') ) } 各种非受控组件 注意，多选下拉框的value应该对应一个数组。 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"ani.html":{"url":"ani.html","title":"动画","keywords":"","body":"动画 建议使用React Motion这个动画库 https://github.com/chenglou/react-motion Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 14:04:53 "},"debug.html":{"url":"debug.html","title":"调试","keywords":"","body":"调试 anu完全兼容官方的chrome开发者工具 先到这里 然后 .aaa { width: 200px; height: 200px; background: red; } .bbb { width: 200px; height: 200px; background: lawngreen; } class App extends React.Component { constructor(props) { super(props) this.state = { aaa: 'aaa' } } change(a){ this.setState({ aaa:a }) } componentDidMount(){ console.log('App componentDidMount') } componentWillUpdate(){ console.log('App componentWillUpdate') } render() { return this.state.aaa === 'aaa' ? : } } class Inner extends React.Component{ constructor(props){ super(props) } componentWillMount(){ console.log('Inner componentWillMount') } componentDidMount(){ console.log('Inner componentDidMount') } componentWillUpdate(){ console.log('Inner componentWillUpdate') } componentDidUpdate(){ console.log('Inner componentDidUpdate') } componentWillUnmount(){ console.log('Inner componentWillUnmount') } render() { return xxx } } class Inner2 extends React.Component{ constructor(props){ super(props) } componentWillMount(){ console.log('Inner2 componentWillMount') } componentDidMount(){ console.log('Inner2 componentDidMount') } componentWillUpdate(){ console.log('Inner2 componentWillUpdate') } componentWillUnmount(){ console.log('Inner2 componentWillUnmount') } render() { return yyy } } var s window.onload = function(){ s = ReactDOM.render( , document.getElementById('example')) } 开发者工具 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"ssr.html":{"url":"ssr.html","title":"后端渲染","keywords":"","body":"服务端渲染 准备动作 1、安装nodejs与安装express 　　安装nodejs教程:http://www.cnblogs.com/pigtail/archive/2013/01/08/2850486.html 　　安装express教程:http://www.expressjs.com.cn/starter/installing.html 2、安装node-jsx（使nodejs支持jsx语法） 　　$ npm install node-jsx 3、安装ejs模板引擎 　　$ npm install ejs 在项目中建立一个app.js，输入 var express = require('express'); var app = express(); app.get('/', function (req, res) { res.send('Hello World!'); }); var server = app.listen(3000, function () { console.log(\"请在浏览器访问：http://localhost:3000/\"); }); 通过如下命令启动此应用： $ node app.js 打开浏览器，输入localhost:3000就看到效果了。 使用模板引擎，我们在建立一个test目录，里面再建一个views目录，模块文件都放里面。 var express = require(\"express\"); var app = express(); //指定模板引擎 app.set(\"view engine\", 'ejs'); //指定模板位置 app.set('views', __dirname + '/test/views'); //利用模板文件home.ejs渲染为html app.get(\"/\", function(req, res) { res.render('home.ejs', { name: '司徒正美' }); }); var server = app.listen(3000, function() { console.log(\"请在浏览器访问：http://localhost:3000/\"); }); 然后我们模块home.ejs my ejs template Hi 如果你嫌弃ejs后缀文件，你的编辑器无法别识（没有语法高亮），可以改进一下，将home.ejs改为home.html var express = require(\"express\"); var app = express(); //指定模板引擎 var ejs = require('ejs'); app.set(\"view engine\", 'ejs'); //指定模板位置 app.set('views', __dirname + '/test/views'); //使用ejs模板引擎解析html视图文件 app.engine('.html',ejs.__express); //利用模板文件home.ejs渲染为html app.get(\"/\", function(req, res) { res.render('home.html', {//这里指定文件名 name: '司徒正美' }); }); var server = app.listen(3000, function() { console.log(\"请在浏览器访问：http://localhost:3000/\"); }); 我们先看一下官方react15.3如何实现后端渲染的 npm install react npm install react-dom 在Test目录下建立一个components目录，里面建一个Test.js，表示这里是一个类 var React=require(\"react\"); class Test extends React.Component{ render(){ return {this.props.name}; } } module.exports = Test 然后修改app.js var express = require(\"express\"); var app = express(); //指定模板引擎 var ejs = require('ejs'); app.set(\"view engine\", 'ejs'); //指定模板位置 app.set('views', __dirname + '/test/views'); //使用ejs模板引擎解析html视图文件 app.engine('.html',ejs.__express); //................ //安装\"node-jsx\"，安装该模块可以使nodejs兼容jsx语法 require(\"node-jsx\").install() var React = global.React = require(\"react\"); var ReactDOMServer = require('react-dom/server') var Test = require('./test/component/Test.js') //引入React组件 //利用模板文件home.ejs渲染为html app.get(\"/\", function(req, res) { res.render('home.html', {//这里指定文件名 component: ReactDOMServer.renderToString( React.createElement( Test,{name:\"司徒正美\"}) ) }) }) //................ var server = app.listen(3000, function() { console.log(\"请在浏览器访问：http://localhost:3000/\"); }); 然后将模板改一下 react 后端渲染 如果想使用anu的后端渲染方案，主要改一下链接就是 var express = require(\"express\"); var app = express(); //指定模板引擎 var ejs = require('ejs'); app.set(\"view engine\", 'ejs'); //指定模板位置 app.set('views', __dirname + '/test/views'); //使用ejs模板引擎解析html视图文件 app.engine('.html',ejs.__express); //................ //安装\"node-jsx\"，安装该模块可以使nodejs兼容jsx语法 require(\"node-jsx\").install() var React = global.React = require(\"./dist/React\"); //var ReactDOMServer = require('react-dom/server') var ReactDOMServer = require('./dist/ReactDOMServer') var Test = require('./test/components/Test.js') //引入React组件 //利用模板文件home.ejs渲染为html app.get(\"/\", function(req, res) { res.render('home.html', {//这里指定文件名 component: ReactDOMServer.renderToString( React.createElement( Test,{name:\"司徒正美\"}) ) }) }) //................ var server = app.listen(3000, function() { console.log(\"请在浏览器访问：http://localhost:3000/\"); }); 但现在前端是一个静态页面，没有JS ，我们让它能活动起来 设置一下静态资态的目录，我把React.js, babel.js什么放到这里上 //app.js app.use(express.static('dist')); 重写一下Test目录，让它有事件 var React=require(\"../../dist/React\"); class Test extends React.Component{ click(){ console.log('=========') } render(){ return {this.props.name} 事件 ; } } module.exports = Test home.html也改一下 react 后端渲染 class Test extends React.Component{ click(){ console.log('=========') } render(){ return {this.props.name} 事件 ; } } window.onload = function(){ ReactDOM.render(, document.getElementById('container')) } 这个后端渲染与前端渲染有什么区别呢？后端渲染会为你的根组件生成的标签添加两个属性data-reactroot与 data-react-checksum。其中后者是为了兼容官网React，anu只需要前者就行了。在前端的ReactDOM.render方法里面，anu会检测插入位置的所有直接孩子，判定它有没有data-reactroot属性，有则进入对齐模式。对齐模式与传统的创建模式不一样。 创建模式是根据虚拟DOM创建一棵真实DOM树，然后移除原容器的所有孩子，插入其中。 对齐模式是因为后端已经将所有孩子直接创建好，但可能会多出一些文本节点。这时它只根据虚拟DOM 的type与真实DOM 的node.toLowerCase()进行比较就是。速度肯定快上几个数量级。 而在实际项目中，我们可以通过babel将Test（会去掉里面的module.export = Test）及其他代码进行打包，不会直接写在页面上的。这样一来 ,就可以达到前后共享一套代码。 https://cnodejs.org/topic/5660f8f9d0bc14ae27939b37 http://blog.csdn.net/mqy1023/article/details/55051788 http://imweb.io/topic/5547892e73d4069201d83e6c http://blog.techbridge.cc/2016/08/27/react-redux-immutablejs-node-server-isomorphic-tutorial/ https://blog.coding.net/blog/React-Server-Side-Rendering-for-SPA-SEO Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"router.html":{"url":"router.html","title":"路由","keywords":"","body":"路由器 anu可以完美与react-router一起使用。 以下例子是基于这个项目改过来的[https://github.com/reactjs/react-router-redux/]（https://github.com/reactjs/react-router-redux/） 注意react-router的版本号为3.0 所有文件可以从这里下 .aaa { width: 200px; height: 200px; background: red; } .bbb { width: 200px; height: 200px; background: lawngreen; } --> --> var s window.onload = function(){ var combineReducers = Redux.combineReducers var createStore = Redux.createStore var Component = React.Component var Provider = ReactRedux.Provider var connect = ReactRedux.connect var Router = ReactRouter.Router var Route = ReactRouter.Route var IndexRoute=ReactRouter.IndexRoute var browserHistory= ReactRouter.browserHistory var Link = ReactRouter.Link var syncHistoryWithStore = ReactRouterRedux.syncHistoryWithStore var routerReducer= ReactRouterRedux.routerReducer const INCREASE = 'INCREASE' const DECREASE = 'DECREASE' const initialState = { number: 1 } // reducers function reducers(state = initialState, action) { if(action.type === INCREASE) { return { number: state.number + action.amount } } else if(action.type === DECREASE) { return { number: state.number - action.amount } } return state } function increase(n) { return { type: INCREASE, amount: n } } function decrease(n) { return { type: DECREASE, amount: n } } //======== 组件 ========= function App({ children }) { return ( Links: {' '} Home {' '} Foo {' '} Bar browserHistory.push('/foo')}>Go to /foo {children} ) } function Bar() { return And I am Bar! } function Foo() { return I am Foo! } function Home({ number, increase, decrease }) { return ( Some state changes: {number} increase(1)}>Increase decrease(1)}>Decrease ) } var Home = connect( state => ({ number: state.number }), { increase, decrease } )(Home) const reducer = combineReducers({ ...reducers, routing: routerReducer }) const store = createStore( reducer ) const history = syncHistoryWithStore(browserHistory, store) ReactDOM.render( , document.getElementById('mount') ) } 这个默认会被清掉 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"redux.html":{"url":"redux.html","title":"redux","keywords":"","body":"redux anu可以直接与redux, react-redux一起使用。 var combineReducers = Redux.combineReducers var Provider = ReactRedux.Provider var connect = ReactRedux.connect const todo = (state, action) => { switch (action.type) { case 'ADD_TODO': return { id: action.id, text: action.text, completed: false } case 'TOGGLE_TODO': if (state.id !== action.id) { return state } return { ...state, completed: !state.completed } default: return state } } const todos = (state = [], action) => { switch (action.type) { case 'ADD_TODO': return [ ...state, todo(undefined, action) ] case 'TOGGLE_TODO': return state.map(t => todo(t, action) ) default: return state } } const visibilityFilter = (state = 'SHOW_ALL', action) => { switch (action.type) { case 'SET_VISIBILITY_FILTER': return action.filter default: return state } } const todoApp = combineReducers({ todos, visibilityFilter }) //===================filters let nextTodoId = 0 const addTodo = (text) => ({ type: 'ADD_TODO', id: nextTodoId++, text }) const setVisibilityFilter = (filter) => ({ type: 'SET_VISIBILITY_FILTER', filter }) const toggleTodo = (id) => ({ type: 'TOGGLE_TODO', id }) const Link = ({ active, children, onClick }) => { if (active) { return {children} } return ( { e.preventDefault() onClick() }} > {children} ) } const Todo = ({ onClick, completed, text }) => ( {text} ) const TodoList = function({ todos, onTodoClick }) { return {todos.map(todo => onTodoClick(todo.id)} /> )} } const Footer = () => ( Show: {\" \"} All {\", \"} Active {\", \"} Completed ) const App = () => ( ) let AddTodo = ({ dispatch }) => { let input return ( { e.preventDefault() if (!input.value.trim()) { return } dispatch(addTodo(input.value)) input.value = '' }}> { input = node }} /> Add Todo (点列表前的圆点切换状态) ) } AddTodo = connect()(AddTodo) const mapStateToProps = (state, ownProps) => ({ active: ownProps.filter === state.visibilityFilter }) const mapDispatchToProps = (dispatch, ownProps) => ({ onClick: () => { dispatch(setVisibilityFilter(ownProps.filter)) } }) const FilterLink = connect( mapStateToProps, mapDispatchToProps )(Link) const getVisibleTodos = (todos, filter) => { switch (filter) { case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t => t.completed) case 'SHOW_ACTIVE': return todos.filter(t => !t.completed) default: throw new Error('Unknown filter: ' + filter) } } const mapStateToProps1 = (state) => ({ todos: getVisibleTodos(state.todos, state.visibilityFilter) }) const mapDispatchToProps1 = { onTodoClick: toggleTodo } const VisibleTodoList = connect( mapStateToProps1, mapDispatchToProps1 )(TodoList) const store = Redux.createStore(todoApp) var s window.onload = function(){ s = ReactDOM.render( , document.getElementById('example') ) } 测试 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"ui.html":{"url":"ui.html","title":"组件库","keywords":"","body":"ui库 建议使用React现成的庞大UI库资源 Ant Design - One Design Language Ant Design 不仅提供了一套完整且丰富的UI组件，而且提供了设计规范而且支持主题定制，除此之外，Ant Design的更新速度与其他许多UI libraries相比，更新速度快很多。 Material UI 非常高的 star 数，帅气的 Material 设计规范实现，巨量 issue 和贡献者，明星级的项目。激进地全局使用了 inline 样式，可能会让部分人群不适应。 reactstrap 基于 bootstrap4 的新起之秀，文档清新，推荐尝试。 React-MDL 能控制每个component的比例，是否在desktop、tablet、phone，使开发人员能够轻松的适配不同设备。 React Toolbox 同样实现了 Material Design 的后起之秀，使用 css-modules，演示文档内建了一个实时编辑器，非常赞。 Elemental UI 网站不错，组件太少，设计风格有点像 Bootstrap。 BFD UI 百分点的 React 套件库，组件很全，风格淡雅，实现质量不错，不知道为什么 star 非常少。 Blueprint - A React UI toolkit for the web 刚刚推出的质量极好的组件库，用 TypeScript 和 Scss 开发，功能强大，并且有自己的色彩和排版规范，推荐使用。 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 13:16:09 "},"ie.html":{"url":"ie.html","title":"旧式IE的支持","keywords":"","body":"旧式IE的支持 Polyfill anu虽然没有用太多高级，但想让它能运行IE6-8,还是需要加许多补丁的，罗列如下： Array.prototype.forEach Function.prototype.bind JSON window.console Object.keys Object.is Object.assign Array.isArray 这些都是整合到lib/polyfill中 React IE专用库 此外，核心库应该由dist/React.js改成dist/ReactIE.js 它相当于原来的库，只是多了一些特殊事件的兼容补丁与innerHTML的修复处理。 IE事件补丁是针对一些不冒泡事件的修复（input, change, submit, focus, blur），及一些特定事件属性的处理(鼠标事件的pageX, pageY, 键盘事件的which, 滚轮事件的wheelDetla) http://www.cnblogs.com/rubylouvre/p/5080464.html 如果用户用到react-transition-group这样的动画，请注意引入requestAnimationFrame的补丁 https://github.com/darius/requestAnimationFrame 压缩 如果你用到压缩，就需要处理 uglify-js产生问题，因为IE6-8 ,对于map.delete(\"ddd\"), modulex.default这样的写法会报语法错误 因为关键字不能做属性名与方法名。我们可以用es3ify-webpack-plugin或es3ify-loader进行处理。 //详见 https://github.com/zuojj/fedlab/issues/5 new webpack.optimize.UglifyJsPlugin({ compress: { properties: false, warnings: false }, output: { beautify: true, quote_keys: true }, mangle: { screw_ie8: false }, sourceMap: false }) 例子 当我们在业务线使用时，需要用webpack进行处理 const webpack = require(\"webpack\"); const path = require(\"path\"); const fs = require(\"fs\"); var es3ifyPlugin = require('es3ify-webpack-plugin'); module.exports = { context: __dirname, entry: { index9: \"./src/index9.js\" }, output: { path: __dirname + \"/dist/\", filename: \"[name].js\" }, plugins: [new es3ifyPlugin()], module: { loaders: [ { test: /\\.jsx?$/, loader: \"babel-loader\", exclude: path.resolve(__dirname, \"node_modules\") } ] }, resolve: { //如果不使用anu，就可以把这里注释掉 alias: { react: \"anujs/dist/ReactIE.js\", \"react-dom\": \"anujs/dist/ReactIE.js\" } } }; 下面示例文件，大家也可以将polyfill与ReactIE 及bable用到的helpers打包一个common.js class Select extends React.Component{ constructor() { super() this.state = { value: 'bbb' } this.onChange = this.onChange.bind(this) } onChange(e){ console.log(e.target.value) this.setState({ value: e.target.value }) } render() { return aaa bbb ccc {this.state.value} } } class Input extends React.Component{ constructor() { super() this.state = { value: 'input' } this.onInput = this.onInput.bind(this) } onInput(e){ this.setState({ value: e.target.value }) } render() { return {this.state.value} } } class Radio extends React.Component{ constructor(props) { super(props) this.state = { value: this.props.value } this.onChange = this.onChange.bind(this) } onChange(e){ console.log(e.target.value) this.setState({ value: e.target.value }) } render() { return {this.state.value+''} } } class Playground extends React.Component{ constructor(props) { super(props) this.state = { value: '请上下滚动鼠标滚轮' } this.onWheel = this.onWheel.bind(this) } onWheel(e){ this.setState({ value: e.wheelDelta }) } render() { return {this.state.value} } } class MouseMove extends React.Component{ constructor(props) { super(props) this.state = { value: '请在绿色区域移动' } this.onMouseMove = this.onMouseMove.bind(this) } onMouseMove(e){ var v = e.pageX+' '+e.pageY; this.setState({ value: v }) } render() { return {this.state.value} } } class FocusEl extends React.Component{ constructor(props) { super(props) this.state = { value: '点我' } this.onFocus = this.onFocus.bind(this) } onFocus(e){ console.log(e.target.title) } render() { return {console.log(e.which)}} style={{width:100,height:50,backgroundColor:'green',display:'inline-block'}} onFocus={this.onFocus} /> } } window.onload = function(){ window.s = ReactDOM.render( , document.getElementById('example')) } .aaa { width: 200px; height: 200px; background: red; } .bbb { width: 200px; height: 200px; background: lawngreen; } 这个默认会被清掉 Copyright © 司徒正美 2013－2016 all right reserved，powered by Gitbook该文件修订时间： 2017-08-29 14:35:38 "}}